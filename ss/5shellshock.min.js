/*VERSION:0.39.6*/

window._utils = {};
window._utils.requirelib = async function(url, global){
  return new Promise(async function(resolve){
    async function getCode(){
      var xmlHttp = new XMLHttpRequest();
      xmlHttp.open( "GET", url, false );
      xmlHttp.send( null );
      return xmlHttp.responseText;
    }
    let code = await getCode();

    if (global){
      code += 'window["' + global + '"] = ' + global + ';';
    }
    let evaluateCode = new Function(code);
    evaluateCode();
    resolve('done');
  });
};

window._utils.requirelib('https://unpkg.com/guify@0.12.0/lib/guify.min.js').then(() => { 
  window.hack.loadGui();
});

window.hack = {
  loadGui: ()=>{},
  modMenu: { 
    credit: {},
    dialog: {},
    menu: { 
      hideOnStart: false,
      focusBind: 'none',
      focusBindHandler: ()=>{},
      focusOnKeyPress: ()=>{},
      forceFocus: false,
      focusSwitch: false,
      hideKey: 'none',
      setHideKey: ()=>{},
      onHidePress: ()=>{},
      container: { 
        label: {},
        resetSettings: {},
        forceSaveSettings: {},
        hideOnStart: {},
        focusBind: {},
        hideKey: {}
      }
    }
  },
  gui: {},
  keyBinds: {
    handler: ()=>{},
    handlePress: ()=>{},
    awaitingBind: false,
    awaitBind: {
      callback: ()=>{},
      onPress: ()=>{},
      binding: ''
    },
    keysBinded: {}
  },
  finishedGui: ()=>{},
  loadSettings: ()=>{},
  modMenuCheck: ()=>{},
  modMenuCheckInterval: ()=>{},
  storeSettings: ()=>{},
  isInChat: ()=>{},
};

window.hack.keyBinds.handler = function(event, doAlert = true){
  let type = (event.key)? "Keyboard" : "Mouse";
  let keybinds = window.hack.keyBinds;
  if (window.hack.keyBinds.awaitingBind){
    let bindString = (event.key)? event.code: "Mouse" + event.button;
    if (bindString == "Escape"){
      
      window.hack.keyBinds.awaitingBind = false;
      window.hack.keyBinds.awaitBind.callback(bindString, true);
      window.hack.modMenu.dialog.close();
      if (doAlert) {alert('Reset Key Bind')};
      return;
    }
    if (bindString == "Insert"){
      if (window.hack.keyBinds.awaitBind.binding != "hideonstart"){
        alert('You can not set ' + bindString + ' to a keybinding!');
        return;
      }
    }
    if (!keybinds.keysBinded[bindString]){
      keybinds.keysBinded[bindString] = {binds: []};
    }
    if (!keybinds.keysBinded[bindString].binds){
      keybinds.keysBinded[bindString] = {binds: []};
    }
    keybinds.keysBinded[bindString].binds.push({binding: window.hack.keyBinds.awaitBind.binding, handle: window.hack.keyBinds.awaitBind.onPress});
    window.hack.keyBinds.awaitBind.callback(bindString);
    window.hack.keyBinds.awaitingBind = false;
    window.hack.modMenu.dialog.close();
    if (doAlert) {alert('Set Keybind To : ' + bindString)};
  }else {
    window.hack.keyBinds.handlePress(event);
  }
}
document.addEventListener('keydown', window.hack.keyBinds.handler);
document.addEventListener('keyup', window.hack.keyBinds.handler);
document.addEventListener('mousedown', window.hack.keyBinds.handler);
document.addEventListener('mouseup', window.hack.keyBinds.handler);

window.hack.modMenu.menu.onHidePress = function(bindString, eventData){
  if (eventData.Type == "up"){
    window.hack.gui.panel.container.hidden = !window.hack.gui.panel.container.hidden;
  }
}
window.hack.modMenu.menu.setHideKey = function(){
  let bindString = window.hack.modMenu.menu.hideKey;
  let keybinds = window.hack.keyBinds;
  if (bindString != 'none'){
    
    if (keybinds.keysBinded[bindString]){
      if (keybinds.keysBinded[bindString].binds){
        keybinds.keysBinded[bindString].binds.forEach((e, i) => {
          if (e.binding == "hide"){
            keybinds.keysBinded[bindString].binds.splice(i, 1);
          }
        });
      }
    }
  }
  window.hack.keyBinds.awaitingBind = true;
  window.hack.keyBinds.awaitBind = {
    callback: (bindString, reset)=>{
      if (!reset){window.hack.modMenu.menu.hideKey = bindString}else {window.hack.modMenu.menu.hideKey = 'none'};
    },
    onPress: window.hack.modMenu.menu.onHidePress,
    binding: 'hide'
  }
  window.hack.modMenu.dialog.show();
}

window.hack.storeSettings = function(){
  let modMenu = window.hack.modMenu;
  let settings = {
    menu: {
      hideOnStart: modMenu.menu.hideOnStart,
      focusBind: modMenu.menu.focusBind,
      hideKey: modMenu.menu.hideKey
    }
  };
  localStorage.hackSettings = JSON.stringify(settings);
}

window.hack.modMenuCheck = function(){
  
  window.hack.storeSettings();
}


window.hack.loadSettings = function(settings){
  let modMenu = window.hack.modMenu;
  if (!settings.menu){
    settings.menu = {};
  }
  modMenu.menu.hideOnStart = (settings.menu.hideOnStart==null)? false : settings.menu.hideOnStart;
  if (modMenu.menu.hideOnStart){
    window.hack.gui.panel.container.hidden = true;
  }

  
  function fakeKeyBind(bindString, binding, callback, onPress){
    let keybinds = window.hack.keyBinds;
    if (bindString != 'none'){
      window.hack.keyBinds.awaitingBind = true;
      window.hack.keyBinds.awaitBind = {
        callback: callback,
        onPress: onPress,
        binding: binding
      }
      let event = {};
      if (bindString.includes('Mouse')){
        event.button = bindString.split('Mouse')[1];
      }else {
        event.key = true;
        event.code = bindString;
      }
      window.hack.keyBinds.handler(event, false);
    }
  }
  if (settings.menu.focusBind != null){
    fakeKeyBind(settings.menu.focusBind, 'focus', (bindString, reset)=>{
      if (!reset){window.hack.modMenu.menu.focusBind = bindString}else {window.hack.modMenu.menu.focusBind = 'none'};
    }, window.hack.modMenu.menu.focusOnKeyPress);
  }
  if (settings.menu.hideKey != null){
    fakeKeyBind(settings.menu.hideKey, 'hide', (bindString, reset)=>{
      if (!reset){window.hack.modMenu.menu.hideKey = bindString}else {window.hack.modMenu.menu.hideKey = 'none'};
    }, window.hack.modMenu.menu.onHidePress);
  }
}


window.hack.finishedGui = function(){
	if (localStorage.hackSettings){
		if (localStorage.hackSettings.split('')[0] != '{'){return;} 
		let previousSettings = JSON.parse(localStorage.hackSettings);
		if (previousSettings != null){
			window.hack.loadSettings(previousSettings);
		}
	}

  
  window.hack.modMenuCheckInterval = setInterval(window.hack.modMenuCheck, 3000);

  
  window.hack.keyBinds.awaitingBind = true;
  window.hack.keyBinds.awaitBind = {
    callback: (bindString, reset) => {},
    onPress: (bindString, eventData) => {
      if (eventData.Type == "up"){
        if (bindString == "Insert"){
          window.hack.gui.panel.container.hidden = !window.hack.gui.panel.container.hidden;
        }
      }
    },
    binding: 'hideonstart'
  }
  let insertEvent = {
    key: true,
    code: "Insert"
  };
  window.hack.keyBinds.handler(insertEvent, false);
}


window.hack.loadGui = function(){
  
  let dialog = document.createElement('dialog');
  dialog.innerHTML = 'Press Any Key or Mouse Button To Set the Keybind!';
  dialog.style.position = "absolute";
  dialog.style.zIndex = "9999";
  dialog.id = "keyBindDialog";
  document.body.appendChild(dialog);
  window.hack.modMenu.dialog = dialog;

  
  window.hack.gui = new guify({
    title: 'CrackWare V5.2.8',
    theme: 'dark',
    align: 'right',
    width: 300,
    barMode: 'none',
    opacity: 0.95,
    root: document.body,
    open: true
  });
  hack.modMenu.menu.container.label = hack.gui.Register({
    type: 'folder',
    label: 'Menu',
    open: false
  });

  hack.modMenu.menu.container.hideOnStart = hack.gui.Register({
    type: 'checkbox',
    label: 'Hide@Load:',
    object: hack.modMenu.menu,
    property: 'hideOnStart',
    folder: 'Menu'
  });

  hack.modMenu.menu.container.resetSettings = hack.gui.Register({
    type: 'button',
    label: 'ResetSettings',
    folder: 'Menu',
    action: function(){
      window.hack.loadSettings({});
    }
  });

  hack.modMenu.menu.container.forceSaveSettings = hack.gui.Register({
    type: 'button',
    label: 'Save Settings',
    folder: 'Menu',
    action: function(){
      window.hack.storeSettings();
    }
  });

  hack.modMenu.menu.container.currentBind = hack.gui.Register({
    type: 'display',
    label: 'FocusKey:',
    folder: 'Menu',
    object: hack.modMenu.menu,
    property: 'focusBind'
  });

  hack.modMenu.menu.container.focusBind = hack.gui.Register({
    type: 'button',
    label: 'Set Focus Key',
    folder: 'Menu',
    action: window.hack.modMenu.menu.focusBindHandler
  });

  hack.modMenu.menu.container.hideKey = hack.gui.Register({
    type: 'display',
    label: 'HideKey:',
    folder: 'Menu',
    object: hack.modMenu.menu,
    property: 'hideKey'
  });

  hack.modMenu.menu.container.setHideKey = hack.gui.Register({
    type: 'button',
    label: 'Set Hide Key',
    folder: 'Menu',
    action: window.hack.modMenu.menu.setHideKey
  });

  
  hack.modMenu.credit = hack.gui.Register({
    type: 'text',
    label: 'Credits'
  });
  
  
  window.hack.modMenu.credit.container.innerHTML = `<p style="color:white;font-size: medium;margin-bottom: 0px;padding-left: 15px;">Hey</p>`

  
  let titleTextElm = window.hack.gui.panel.panel.childNodes[0];
  titleTextElm.style.color = "rgb(0, 196, 255)";
  titleTextElm.style.fontWeight = "bold";

  
  window.hack.finishedGui();
}
                            
let codeVersion = "0.39.6";
let gameVersion = window.version;
if (codeVersion != gameVersion){
  alert(`JeffWare Code Version does not match ShellShockers current version

JeffWare Version: ${codeVersion}
Game Version: ${gameVersion}`);
}
